#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#include "PCB.h"
using namespace std;

bool compareByArrivalTime(const PCB &a, const PCB &b) {
	// Function to sort based on arrival times of two PCBs
	return a.arrivalTime < b.arrivalTime;
}

int main(int argc, char* argv[]) {
	int const MAX_SIZE = 256;
	int const NUM_GEN_ARGS = 4;		// Number of args sent to Generator process
	int size = 0;
	int timer = 0;					// Pseudo CPU timer 
	int numProcesses;				// Number of processes generated by user
	int processesRemaining = 0;		// Number of processes still left to receive
	PCB processControl;				// An instance of a PCB structure
	PCB runningProcess;				// Process the CPU is previously working on
	priority_queue<PCB> readyQueue;	// Stores processes waiting to be executed
	vector<PCB> arrivalQueue; 		// Temporarily stores simulated processes
	vector<PCB> processes;			// Stores completed processes for output
	
	runningProcess.arrivalTime = -1; // Used later for a check
	
	char numProcessBuffer[MAX_SIZE];
	char generatorProgName[MAX_SIZE];
	char *generatorargv[NUM_GEN_ARGS];
	char pipeArgvWrite[MAX_SIZE];
	pid_t generatorPID;
	
	int pipefd[2]; // Generator to Scheduler pipe
	
	numProcesses = atoi(argv[1]);
	processesRemaining = numProcesses;
	
	strcpy(numProcessBuffer, to_string(numProcesses).c_str());
	strcpy(generatorProgName, "./generator");
	
	// Initialize generatoargv array to NULL
	for(int i = 0; i < NUM_GEN_ARGS; i++) {
		generatorargv[i] = NULL;
	}
	
	generatorargv[0] = generatorProgName;
	generatorargv[1] = numProcessBuffer;  // Number of processes to simulate
	generatorargv[2] = pipeArgvWrite; // Generator pipe write info
	generatorargv[3] = NULL;
	
	// If Generator to Scheduler pipe creation fails, throw an error and exit
	if (pipe(pipefd) == -1) {
		perror("pipe");
		exit(1);
	}
	
	generatorPID = fork();	// Fork the generator process
	if (generatorPID < 0){
		// Fork error
		printf("Fork failed");
		exit(2);
	}
	else if (generatorPID == 0) {
		// Child process
		size = sprintf (pipeArgvWrite, "%d", pipefd[1]);
		if (execvp(generatorargv[0], generatorargv) == -1) {
			// Exec command failed, print error and exit
			printf("Failure to execute because %s\n", strerror(errno));
			exit(3);
		}
		exit(4);
	}
	
	while (readyQueue.size() != 0 || arrivalQueue.size() != 0 || processesRemaining != 0) {
		if (processesRemaining > 0) {
			// There are PCBs still waiting to be read
			read(pipefd[0], (void*) &processControl, sizeof(processControl));
			processesRemaining -= 1;
			// The process is placed in a psuedo arrival queue
			// Note: This queue is not the ready queue and PCBs are moved to the ready queue later
			if (runningProcess.arrivalTime == -1) {
				// If this is the first process, put it straight into the readyQueue
				readyQueue.push(processControl);
				timer = processControl.arrivalTime;
				runningProcess.arrivalTime = 0;
			}
			else {
				// Otherwise put it into the arrivalQueue
				arrivalQueue.push_back(processControl);
			}
		}
		if (arrivalQueue.size() != 0) {
			// If the arrivalQueue is not empty, add all eligible processes to readyQueue
			for (int i = 0; i < arrivalQueue.size(); i++) {
				// Push valid processes to readyQueue
				if (arrivalQueue[i].arrivalTime < timer) {
					cout << "Pushing PCB: ArrivalTime - " << arrivalQueue[i].arrivalTime << " CPUBurst - " << arrivalQueue[i].CPUburst << endl;
					readyQueue.push(arrivalQueue[i]);
				}
				else {
					cout << "Arrival time is: " << arrivalQueue[i].arrivalTime << " Timer is: " << timer << endl;
				}
			}
			for (int i = 0; i < arrivalQueue.size(); i++) {
				// Cleanup
				if (arrivalQueue[i].arrivalTime < timer) {
					arrivalQueue.erase(arrivalQueue.begin() + i);
				}
			}
		}
		if (readyQueue.size() != 0) {
			// If the readyQueue is not empty, select a process off of the queue
			cout << readyQueue.size() << endl;
			PCB selectProcess = readyQueue.top(); // Grab the PCB at the top of the priority queue
			readyQueue.pop();
			PCB runningProcess = selectProcess; // Set the current running process
			selectProcess.waitingTime = timer - selectProcess.arrivalTime; // Compute waiting time
			timer += selectProcess.CPUburst; 	// Increment CPU timer and add CPU burst
			processes.push_back(selectProcess); // Add completed process to processes vector
		}
		// If the readyQueue is empty, increment CPU timer
		timer++;
	}
	
	close(pipefd[0]); // Close the read end of the pipe
	close(pipefd[1]); // Close the write end of the pipe
	
	sort(processes.begin(), processes.end(), compareByArrivalTime); // Sort the processes vector by arrival times
	
	for(int i = 0; i < processes.size(); i++) {
		cout << processes[i].arrivalTime << " " << i+1 << " " << processes[i].CPUburst << " " << processes[i].waitingTime << endl;
	}
	
	return 0;
}