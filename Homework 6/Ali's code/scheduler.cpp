/*============================================================
COURSE:				CSC460, hw6
PROGRAMMERS:		Ali Bajwa (ab) 			50% Contribution
						Documentation
						generator.cpp
						makefile
						PCB.h
						scheduler.cpp
						fileoutput.cpp
						fileoutput.h

					Noah Bumgardner (nb)	50% Contribution
						Checked CL argument
						Documentation generator.cpp header
						Encouraged group meetings
						Gathered reusable code
						Printed final copy
						scheduler.h

LAST MODIFIED DATE:	2015-12-02
DESCRIPTION:		This program generates a non-duplicated
				child process to generate n pairs of integers
				representing processes.
				...
				The program write the results over the text
				file 'record.txt'.
NOTE:				If the command line integer is negative,
					 it is replaced with zero. A negative
					 number of processes does not make sense.
FILES:							generator.cpp, makefile,
								PCB.h, scheduler.cpp, scheduler.h,
								fileoutput.cpp, fileoutput.h
IDE/COMPILER/INTERPRETER:		GNU g++
INSTRUCTION FOR COMPILATION AND EXECUTION:		(Use makefile)
 1. type:  make					to COMPILE
 2. type:  ./scheduler  n		to EXECUTE
============================================================*/
#include "scheduler.h"
using namespace std;

void CompleteAProcess(priority_queue<PCB>& readyQueue, vector<PCB>& processes, int& timer) {
	PCB selectProcess = readyQueue.top(); // Grab the PCB at the top of the priority queue
	readyQueue.pop();
	selectProcess.waitingTime = timer - selectProcess.arrivalTime; // Compute waiting time
	timer += selectProcess.CPUburst; 	// Increment CPU timer and add CPU burst
	processes.push_back(selectProcess); // Add completed process to processes vector
}

int main(int argc, char* argv[]) {
	int const MAX_SIZE = 256;
	int const NUM_GEN_ARGS = 4;		// Number of args sent to Generator process
	int size = 0;
	int timer = 33;					// Pseudo CPU timer 
	int numProcesses;				// Number of processes generated by user
	int processesRemaining = 0;		// Number of processes still left to receive
	PCB processControl;				// An instance of a PCB structure
	priority_queue<PCB> readyQueue;	// Stores processes waiting to be executed
	vector<PCB> arrivalQueue; 		// Temporarily stores simulated processes
	vector<PCB> processes;			// Stores completed processes for output
	
	char numProcessBuffer[MAX_SIZE];
	char generatorProgName[MAX_SIZE];
	char *generatorargv[NUM_GEN_ARGS];
	char pipeArgvWrite[MAX_SIZE];
	pid_t generatorPID;
	
	int pipefd[2]; // Generator to Scheduler pipe
	
	// Check number of parameters
	if (argc != 2) {
		cout << "ERROR. The correct usage of this program is:"
		 << " ./scheduler [n] (where n is non-negative)" << endl;
		exit(1);
	}

	// Make first parameter non-negative, since it represents
	//  the number of processes which will be made.
	numProcesses = atoi(argv[1]);
	if (numProcesses < 0) {
		numProcesses = 0;
	}
	processesRemaining = numProcesses;
	
	strcpy(numProcessBuffer, to_string(numProcesses).c_str());
	strcpy(generatorProgName, "./generator");
	
	// Initialize generatorargv array to NULL
	for(int i = 0; i < NUM_GEN_ARGS; i++) {
		generatorargv[i] = NULL;
	}
	
	generatorargv[0] = generatorProgName;
	generatorargv[1] = numProcessBuffer;  // Number of processes to simulate
	generatorargv[2] = pipeArgvWrite; // Generator pipe write info
	generatorargv[3] = NULL;
	
	// If Generator to Scheduler pipe creation fails, throw an error and exit
	if (pipe(pipefd) == -1) {
		perror("pipe");
		exit(1);
	}
	
	generatorPID = fork();	// Fork the generator process
	if (generatorPID < 0){
		// Fork error
		printf("Fork failed");
		exit(2);
	}
	else if (generatorPID == 0) {
		// Child process
		size = sprintf (pipeArgvWrite, "%d", pipefd[1]);
		if (execvp(generatorargv[0], generatorargv) == -1) {
			// Exec command failed, print error and exit
			printf("Failure to execute because %s\n", strerror(errno));
			exit(3);
		}
		exit(4);
	}
	
	while (processesRemaining != 0) {				
		// There are PCBs still waiting to be read
		read(pipefd[0], (void*) &processControl, sizeof(processControl));

		// The process is placed in a psuedo arrival queue
		if (processesRemaining == numProcesses) {
			readyQueue.push(processControl);
			timer = processControl.arrivalTime;
		}
		else {
			arrivalQueue.push_back(processControl);
		}

		processesRemaining -= 1;
	}
	
	while (arrivalQueue.size() != 0 || readyQueue.size() != 0) {
		if (arrivalQueue.size() != 0) {
			// If the arrivalQueue is not empty, add all eligible processes to readyQueue
			for (int i = 0; i < arrivalQueue.size(); i++) {
				// Push valid processes to readyQueue
				if (arrivalQueue[i].arrivalTime < timer) {
					readyQueue.push(arrivalQueue[i]);
					arrivalQueue.erase(arrivalQueue.begin() + i);
				}
			}
		}
		
		if (arrivalQueue.size() != 0 && readyQueue.size() == 0) {
			timer++;
		}
		
		if (readyQueue.size() != 0) {
			CompleteAProcess(readyQueue, processes, timer);
		}
	}
	
	close(pipefd[0]); // Close the read end of the pipe
	close(pipefd[1]); // Close the write end of the pipe
	
	// Sort the processes vector by arrival times
	sort(processes.begin(), processes.end(), compareByArrivalTime);
	
	fileOutput(processes);
	
	return 0;
}