/*============================================================
COURSE:				CSC460, hw6
PROGRAMMERS:		Ali Bajwa (ab) 			50% Contribution
						Documentation
						generator.cpp
						makefile
						PCB.h
						scheduler.cpp
						fileoutput.cpp
						fileoutput.h

					Noah Bumgardner (nb)	50% Contribution
						Checked CL argument
						Documentation generator.cpp header
						Encouraged group meetings
						Gathered reusable code
						Printed final copy
						scheduler.h

LAST MODIFIED DATE:	2015-12-02
DESCRIPTION:		This program generates a non-duplicated
				child process to generate n pairs of integers
				representing processes.
				...
				The program write the results over the text
				file 'record.txt'.
NOTE:				If the command line integer is negative,
					 it is replaced with zero. A negative
					 number of processes does not make sense.
FILES:							generator.cpp, makefile,
								PCB.h, scheduler.cpp, scheduler.h,
								fileoutput.cpp, fileoutput.h
IDE/COMPILER/INTERPRETER:		GNU g++
INSTRUCTION FOR COMPILATION AND EXECUTION:		(Use makefile)
 1. type:  make					to COMPILE
 2. type:  ./scheduler  n		to EXECUTE
============================================================*/
#include "scheduler.h"
using namespace std;


int main(int argc, char* argv[]) {
	int const MAX_SIZE = 256;
	int const NUM_GEN_ARGS = 4;		// Number of args sent to Generator process
	int size = 0;
	int timer = 0;					// Pseudo CPU timer 
	int numProcesses;				// Number of processes generated by user
	int processesRemaining = 0;		// Number of processes still left to receive
	PCB processControl;				// An instance of a PCB structure
	PCB runningProcess;				// Process the CPU is previously working on
	priority_queue<PCB> readyQueue;	// Stores processes waiting to be executed
	vector<PCB> arrivalQueue; 		// Temporarily stores simulated processes
	vector<PCB> processes;			// Stores completed processes for output
	
	runningProcess.arrivalTime = -1; // Used later for a check
	
	char numProcessBuffer[MAX_SIZE];
	char generatorProgName[MAX_SIZE];
	char *generatorargv[NUM_GEN_ARGS];
	char pipeArgvWrite[MAX_SIZE];
	pid_t generatorPID;
	
	int pipefd[2]; // Generator to Scheduler pipe
	
	// Check number of parameters
	if (argc != 2) {
		cout << "ERROR. The correct usage of this program is:"
		 << " ./scheduler [n] (where n is non-negative)" << endl;
		exit(1);
	}

	// Make first parameter non-negative, since it represents
	//  the number of processes which will be made.
	numProcesses = atoi(argv[1]);
	if (numProcesses < 0) {
		numProcesses = 0;
	}
	processesRemaining = numProcesses;
	
	strcpy(numProcessBuffer, to_string(numProcesses).c_str());
	strcpy(generatorProgName, "./generator");
	
	// Initialize generatorargv array to NULL
	for(int i = 0; i < NUM_GEN_ARGS; i++) {
		generatorargv[i] = NULL;
	}
	
	generatorargv[0] = generatorProgName;
	generatorargv[1] = numProcessBuffer;  // Number of processes to simulate
	generatorargv[2] = pipeArgvWrite; // Generator pipe write info
	generatorargv[3] = NULL;
	
	// If Generator to Scheduler pipe creation fails, throw an error and exit
	if (pipe(pipefd) == -1) {
		perror("pipe");
		exit(1);
	}
	
	generatorPID = fork();	// Fork the generator process
	if (generatorPID < 0){
		// Fork error
		printf("Fork failed");
		exit(2);
	}
	else if (generatorPID == 0) {
		// Child process
		size = sprintf (pipeArgvWrite, "%d", pipefd[1]);
		if (execvp(generatorargv[0], generatorargv) == -1) {
			// Exec command failed, print error and exit
			printf("Failure to execute because %s\n", strerror(errno));
			exit(3);
		}
		exit(4);
	}
	
	while (readyQueue.size() != 0 || arrivalQueue.size() != 0 || processesRemaining != 0) {
		if (processesRemaining > 0) {
			// There are PCBs still waiting to be read
			read(pipefd[0], (void*) &processControl, sizeof(processControl));
			processesRemaining -= 1;
			// The process is placed in a psuedo arrival queue
			// Note: This queue is not the ready queue and PCBs are moved to the ready queue later
			if (runningProcess.arrivalTime == -1) {
				// If this is the first process, put it straight into the readyQueue
				readyQueue.push(processControl);
				timer = processControl.arrivalTime;
				runningProcess.arrivalTime = 0;
			}
			else {
				// Otherwise put it into the arrivalQueue
				arrivalQueue.push_back(processControl);
			}
		}
		if (arrivalQueue.size() != 0) {
			// If the arrivalQueue is not empty, add all eligible processes to readyQueue
			for (int i = 0; i < arrivalQueue.size(); i++) {
				// Push valid processes to readyQueue
				if (arrivalQueue[i].arrivalTime < timer) {
					cout << "Pushing PCB: ArrivalTime - " << arrivalQueue[i].arrivalTime << " CPUBurst - " << arrivalQueue[i].CPUburst << endl;
					readyQueue.push(arrivalQueue[i]);
				}
				else {
					cout << "Arrival time is: " << arrivalQueue[i].arrivalTime << " Timer is: " << timer << endl;
				}
			}
			for (int i = 0; i < arrivalQueue.size(); i++) {
				// Cleanup
				if (arrivalQueue[i].arrivalTime < timer) {
					arrivalQueue.erase(arrivalQueue.begin() + i);
				}
			}
		}
		if (readyQueue.size() != 0) {
			// If the readyQueue is not empty, select a process off of the queue
			cout << readyQueue.size() << endl;
			PCB selectProcess = readyQueue.top(); // Grab the PCB at the top of the priority queue
			readyQueue.pop();
			PCB runningProcess = selectProcess; // Set the current running process
			selectProcess.waitingTime = timer - selectProcess.arrivalTime; // Compute waiting time
			timer += selectProcess.CPUburst; 	// Increment CPU timer and add CPU burst
			processes.push_back(selectProcess); // Add completed process to processes vector
		}
		// If the readyQueue is empty, increment CPU timer
		timer++;
	}
	
	close(pipefd[0]); // Close the read end of the pipe
	close(pipefd[1]); // Close the write end of the pipe
	
	// Sort the processes vector by arrival times
	sort(processes.begin(), processes.end(), compareByArrivalTime);
	
	fileOutput(processes);
	
	for(int i = 0; i < processes.size(); i++) {
		cout << processes[i].arrivalTime << " "
			<< i+1 << " "
			<< processes[i].CPUburst << " "
			<< processes[i].waitingTime << endl;
	}
	
	return 0;
}